<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Star Nebula</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Arial', sans-serif;
        }
        
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="info">
        <div>ðŸŒŒ Star Nest - Volumetric Nebula</div>
        <div style="margin-top: 5px; font-size: 12px; opacity: 0.8;">Fractal Volumetric Rendering</div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('webgl2');
        
        if (!gl) {
            alert('WebGL is not supported in your browser!');
        } else {
            init();
        }

        function init() {
            // Set canvas size
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Vertex shader source
            const vertexShaderSource = `
                attribute vec2 a_position;
                void main() {
                    gl_Position = vec4(a_position, 0.0, 1.0);
                }
            `;

            // Fragment shader source - Star Nest Volumetric Nebula
            const fragmentShaderSource = `
                precision highp float;
                
                uniform float u_time;
                uniform vec2 u_resolution;
                
                #define iterations 17
                #define formuparam 0.53
                
                #define volsteps 20
                #define stepsize 0.1
                
                #define zoom 0.800
                #define tile 0.850
                #define speed 0.010
                
                #define brightness 0.0015
                #define darkmatter 0.300
                #define distfading 0.730
                #define saturation 0.850
                
                // Rotation matrix
                mat2 rot2D(float a) {
                    float s = sin(a);
                    float c = cos(a);
                    return mat2(c, -s, s, c);
                }
                
                void main() {
                    // Get coords and direction
                    vec2 uv = (gl_FragCoord.xy / u_resolution.xy) - 0.5;
                    uv.y *= u_resolution.y / u_resolution.x;
                    vec3 dir = vec3(uv * zoom, 1.0);
                    float time = u_time * speed + 0.25;
                    
                    // Auto rotation (can be replaced with mouse input)
                    float a1 = 0.5 + sin(time * 0.1) * 0.3;
                    float a2 = 0.8 + cos(time * 0.15) * 0.2;
                    mat2 rot1 = rot2D(a1);
                    mat2 rot2 = rot2D(a2);
                    dir.xz *= rot1;
                    dir.xy *= rot2;
                    
                    vec3 from = vec3(1.0, 0.5, 0.5);
                    from += vec3(time * 2.0, time, -2.0);
                    from.xz *= rot1;
                    from.xy *= rot2;
                    
                    // Volumetric rendering
                    float s = 0.1;
                    float fade = 1.0;
                    vec3 v = vec3(0.0);
                    
                    for (int r = 0; r < volsteps; r++) {
                        vec3 p = from + s * dir * 0.5;
                        // Tiling fold
                        p = abs(vec3(tile) - mod(p, vec3(tile * 2.0)));
                        
                        float pa = 0.0;
                        float a = 0.0;
                        
                        // Fractal iterations
                        for (int i = 0; i < iterations; i++) {
                            // The magic formula - creates the fractal structure
                            p = abs(p) / dot(p, p) - formuparam;
                            a += abs(length(p) - pa); // Absolute sum of average change
                            pa = length(p);
                        }
                        
                        float dm = max(0.0, darkmatter - a * a * 0.001); // Dark matter
                        a *= a * a; // Add contrast
                        
                        if (r > 6) fade *= 1.0 - dm; // Dark matter, don't render near
                        
                        v += fade;
                        // Coloring based on distance - creates depth and color variation
                        v += vec3(s, s * s, s * s * s * s) * a * brightness * fade;
                        fade *= distfading; // Distance fading
                        s += stepsize;
                    }
                    
                    // Color adjustment with saturation
                    v = mix(vec3(length(v)), v, saturation);
                    
                    // Final color output
                    gl_FragColor = vec4(v * 0.01, 1.0);
                }
            `;

            // Compile shader
            function compileShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                
                return shader;
            }

            // Create shader program
            function createProgram(gl, vertexShader, fragmentShader) {
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Program linking error:', gl.getProgramInfoLog(program));
                    gl.deleteProgram(program);
                    return null;
                }
                
                return program;
            }

            // Setup
            const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            const program = createProgram(gl, vertexShader, fragmentShader);

            if (!program) {
                alert('Failed to create shader program. Check console for errors.');
                return;
            }
            
            console.log('Star Nest shader program created successfully');
            console.log('Canvas size:', canvas.width, 'x', canvas.height);

            // Create fullscreen quad
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [
                -1, -1,
                 1, -1,
                -1,  1,
                -1,  1,
                 1, -1,
                 1,  1,
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            // Get attribute and uniform locations
            const positionLocation = gl.getAttribLocation(program, 'a_position');
            const timeLocation = gl.getUniformLocation(program, 'u_time');
            const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');

            // Render loop
            function render(time) {
                if (!program) return;
                
                time *= 0.001; // Convert to seconds
                
                gl.useProgram(program);
                
                // Set uniforms
                gl.uniform1f(timeLocation, time);
                gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
                
                // Set up position attribute
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Clear and draw
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                requestAnimationFrame(render);
            }

            // Start rendering
            requestAnimationFrame(render);
        }
    </script>
</body>
</html>

